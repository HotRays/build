diff --git a/drivers/devfreq/dramfreq/sunxi-ddrfreq.c b/drivers/devfreq/dramfreq/sunxi-ddrfreq.c
old mode 100755
new mode 100644
index 654cfd7f4d56..c7c20b713a3c
--- a/drivers/devfreq/dramfreq/sunxi-ddrfreq.c
+++ b/drivers/devfreq/dramfreq/sunxi-ddrfreq.c
@@ -1666,7 +1666,7 @@ static __devinit int sunxi_ddrfreq_probe(struct platform_device *pdev)
 	if (sunxi_ddrfreq_min < SUNXI_DDRFREQ_MINFREQ_MIN)
 		sunxi_ddrfreq_min = sunxi_ddrfreq_max / 3;
 #elif defined(CONFIG_ARCH_SUN8IW7P1)
-	sunxi_ddrfreq_min = 132000;
+	sunxi_ddrfreq_min = 408000;
 #else
 	type = script_get_item("dram_para", "dram_tpr12", &val);
 	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
diff --git a/drivers/i2c/busses/i2c-sunxi.c b/drivers/i2c/busses/i2c-sunxi.c
old mode 100755
new mode 100644
index f47704bf1414..2592bd48187c
--- a/drivers/i2c/busses/i2c-sunxi.c
+++ b/drivers/i2c/busses/i2c-sunxi.c
@@ -438,9 +438,12 @@ static int twi_start(void __iomem *base_addr, int bus_num)
 	return SUNXI_I2C_OK;
 }
 
+static int twi_stop(void __iomem *base_addr, int bus_num);
 static int twi_restart(void __iomem *base_addr, int bus_num)
 {
 	unsigned int timeout = 0xff;
+	twi_stop(base_addr, bus_num);
+	mdelay(1);
 	twi_set_start(base_addr);
 	twi_clear_irq_flag(base_addr);
 	while((1 == twi_get_start(base_addr))&&(--timeout));
diff --git a/drivers/video/fbtft/Kconfig b/drivers/video/fbtft/Kconfig
index 52d7b2195e6f..af431e856fcd 100644
--- a/drivers/video/fbtft/Kconfig
+++ b/drivers/video/fbtft/Kconfig
@@ -116,6 +116,12 @@ config FB_TFT_ST7735R
 	help
 	  Generic Framebuffer support for ST7735R
 
+config FB_TFT_ST7735S
+	tristate "FB driver for the ST7735S LCD Controller"
+	depends on FB_TFT
+	help
+	  Generic Framebuffer support for ST7735S
+
 config FB_TFT_TINYLCD
 	tristate "FB driver for tinylcd.com display"
 	depends on FB_TFT
diff --git a/drivers/video/fbtft/Makefile b/drivers/video/fbtft/Makefile
index b0b24a16af74..e9ac45d2b0ce 100644
--- a/drivers/video/fbtft/Makefile
+++ b/drivers/video/fbtft/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_FB_TFT_SSD1306)     += fb_ssd1306.o
 obj-$(CONFIG_FB_TFT_SSD1331)     += fb_ssd1331.o
 obj-$(CONFIG_FB_TFT_SSD1351)     += fb_ssd1351.o
 obj-$(CONFIG_FB_TFT_ST7735R)     += fb_st7735r.o
+obj-$(CONFIG_FB_TFT_ST7735S)     += fb_st7735s.o
 obj-$(CONFIG_FB_TFT_TINYLCD)     += fb_tinylcd.o
 obj-$(CONFIG_FB_TFT_TLS8204)     += fb_tls8204.o
 obj-$(CONFIG_FB_TFT_UPD161704)   += fb_upd161704.o
diff --git a/drivers/video/fbtft/fb_st7735s.c b/drivers/video/fbtft/fb_st7735s.c
new file mode 100644
index 000000000000..3161511cca39
--- /dev/null
+++ b/drivers/video/fbtft/fb_st7735s.c
@@ -0,0 +1,193 @@
+/*
+ * FB driver for the ST7735S LCD Controller
+ *
+ * Copyright (C) 2013 Noralf Tronnes
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include "fbtft.h"
+
+#define DRVNAME "fb_st7735s"
+#define DEFAULT_GAMMA "0F 1A 0F 18 2F 28 20 22 1F 1B 23 37 00 07 02 10\n" \
+                      "0F 1B 0F 17 33 2C 29 2E 30 30 39 3F 00 07 03 10"
+
+
+static int default_init_sequence[] = {
+	/* SWRESET - Software reset */
+	-1, 0x01,                                
+	-2, 150,                               /* delay */
+
+	/* SLPOUT - Sleep out & booster on */
+	-1, 0x11,                          
+	-2, 500,                               /* delay */
+
+	/* FRMCTR1 - frame rate control: normal mode
+	     frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D) */
+	-1, 0xB1, 0x01, 0x2C, 0x2D, 
+
+	/* FRMCTR2 - frame rate control: idle mode
+	     frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D) */
+	-1, 0xB2, 0x01, 0x2C, 0x2D, 
+
+	/* FRMCTR3 - frame rate control - partial mode
+	     dot inversion mode, line inversion mode */
+	-1, 0xB3, 0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D,
+
+	/* INVCTR - display inversion control
+	     no inversion */
+	-1, 0xB4, 0x07,
+
+	/* PWCTR1 - Power Control
+	     -4.6V, AUTO mode */
+	-1, 0xC0, 0xA2, 0x02, 0x84,
+
+	/* PWCTR2 - Power Control
+	     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD */
+	-1, 0xC1, 0xC5,
+
+	/* PWCTR3 - Power Control
+	     Opamp current small, Boost frequency */
+	-1, 0xC2, 0x0A, 0x00,
+
+	/* PWCTR4 - Power Control
+	     BCLK/2, Opamp current small & Medium low */
+	-1, 0xC3,0x8A,0x2A,
+
+	/* PWCTR5 - Power Control */
+	-1, 0xC4, 0x8A, 0xEE,
+
+	/* VMCTR1 - Power Control */
+	-1, 0xC5, 0x0E,
+
+	/* INVOFF - Display inversion off */
+	-1, 0x20,
+
+	/* COLMOD - Interface pixel format */
+	-1, 0x3A, 0x05,
+
+	/* DISPON - Display On */
+	-1, 0x29,
+	-2, 100,                               /* delay */
+
+	/* NORON - Partial off (Normal) */
+	-1, 0x13,
+	-2, 10,                               /* delay */
+
+	/* end marker */
+	-3                                  
+};
+
+static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
+{
+	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
+		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
+
+	/* Column address */
+	write_reg(par, 0x2A, xs >> 8, xs & 0xFF, xe >> 8, xe & 0xFF);
+
+	/* Row adress */
+	write_reg(par, 0x2B, ys >> 8, ys & 0xFF, ye >> 8, ye & 0xFF);
+
+	/* Memory write */
+	write_reg(par, 0x2C);
+}
+
+#define MY (1 << 7)
+#define MX (1 << 6)
+#define MV (1 << 5)
+static int set_var(struct fbtft_par *par)
+{
+	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
+
+	/* MADCTL - Memory data access control
+	     RGB/BGR:
+	     1. Mode selection pin SRGB
+	        RGB H/W pin for color filter setting: 0=RGB, 1=BGR
+	     2. MADCTL RGB bit
+	        RGB-BGR ORDER color filter panel: 0=RGB, 1=BGR */
+	switch (par->info->var.rotate) {
+	case 0:
+		write_reg(par, 0x36, MX | MY | (par->bgr << 3));
+		break;
+	case 270:
+		write_reg(par, 0x36, MY | MV | (par->bgr << 3));
+		break;
+	case 180:
+		write_reg(par, 0x36, (par->bgr << 3));
+		break;
+	case 90:
+		write_reg(par, 0x36, MX | MV | (par->bgr << 3));
+		break;
+	}
+
+	return 0;
+}
+
+/*
+  Gamma string format:
+    VRF0P VOS0P PK0P PK1P PK2P PK3P PK4P PK5P PK6P PK7P PK8P PK9P SELV0P SELV1P SELV62P SELV63P
+    VRF0N VOS0N PK0N PK1N PK2N PK3N PK4N PK5N PK6N PK7N PK8N PK9N SELV0N SELV1N SELV62N SELV63N
+*/
+#define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
+static int set_gamma(struct fbtft_par *par, unsigned long *curves)
+{
+	int i,j;
+
+	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
+
+	/* apply mask */
+	for (i = 0; i < par->gamma.num_curves; i++)
+		for (j = 0; j < par->gamma.num_values; j++)
+			CURVE(i,j) &= 0b111111;
+
+	for (i = 0; i < par->gamma.num_curves; i++)
+		write_reg(par, 0xE0 + i,
+			CURVE(i, 0), CURVE(i, 1), CURVE(i, 2), CURVE(i, 3),
+			CURVE(i, 4), CURVE(i, 5), CURVE(i, 6), CURVE(i, 7),
+			CURVE(i, 8), CURVE(i, 9), CURVE(i, 10), CURVE(i, 11),
+			CURVE(i, 12), CURVE(i, 13), CURVE(i, 14), CURVE(i,15));
+
+	return 0;
+}
+#undef CURVE
+
+
+static struct fbtft_display display = {
+	.regwidth = 8,
+	.width = 80,
+	.height = 160,
+	.init_sequence = default_init_sequence,
+	.gamma_num = 2,
+	.gamma_len = 16,
+	.gamma = DEFAULT_GAMMA,
+	.fbtftops = {
+		.set_addr_win = set_addr_win,
+		.set_var = set_var,
+		.set_gamma = set_gamma,
+	},
+};
+FBTFT_REGISTER_DRIVER(DRVNAME, &display);
+
+MODULE_ALIAS("spi:" DRVNAME);
+MODULE_ALIAS("platform:" DRVNAME);
+
+MODULE_DESCRIPTION("FB driver for the ST7735R LCD Controller");
+MODULE_AUTHOR("Noralf Tronnes");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbtft/fbtft_device.c b/drivers/video/fbtft/fbtft_device.c
index c3cbdc9575d6..23eeac6f6f01 100644
--- a/drivers/video/fbtft/fbtft_device.c
+++ b/drivers/video/fbtft/fbtft_device.c
@@ -108,7 +108,7 @@ static int init_num;
 module_param_array(init, int, &init_num, 0);
 MODULE_PARM_DESC(init, "Init sequence, used with the custom argument");
 
-static unsigned long debug;
+static unsigned long debug = 7;
 module_param(debug, ulong , 0);
 MODULE_PARM_DESC(debug,
 "level: 0-7 (the remaining 29 bits is for advanced usage)");
@@ -711,6 +711,23 @@ static struct fbtft_device_display displays[] = {
 				},
 			}
 		}
+	}, {
+		.name = "fb_st7735s",
+		.spi = &(struct spi_board_info) {
+			.modalias = "fb_st7735s",
+			.max_speed_hz = 32000000,
+			.mode = SPI_MODE_0,
+			.platform_data = &(struct fbtft_platform_data) {
+				.display = {
+					.buswidth = 8,
+				},
+				.gpios = (const struct fbtft_gpio []) {
+					{ "reset", 2 },
+					{ "dc", 3 },
+					{},
+				},
+			}
+		}
 	}, {
 		.name = "sainsmart32",
 		.pdev = &(struct platform_device) {
diff --git a/drivers/video/sunxi/disp2/disp/de/disp_display.c b/drivers/video/sunxi/disp2/disp/de/disp_display.c
index 37084b7cb3a6..093cfb78e92c 100755
--- a/drivers/video/sunxi/disp2/disp/de/disp_display.c
+++ b/drivers/video/sunxi/disp2/disp/de/disp_display.c
@@ -779,6 +779,10 @@ s32 bsp_disp_get_screen_width_from_output_type(u32 disp, u32 output_type, u32 ou
 			width = 2048;
 			height = 1536;
 			break;
+		case DISP_TV_MOD_1600_900P:
+			width = 1600;
+			height = 900;
+			break;
 		}
 	}
 	/* FIXME: add other output device res */
@@ -859,6 +863,10 @@ s32 bsp_disp_get_screen_height_from_output_type(u32 disp, u32 output_type, u32 o
 			width = 2048;
 			height = 1536;
 			break;
+		case DISP_TV_MOD_1600_900P:
+			width = 1600;
+			height = 900;
+			break;
 		}
 	}
 	/* FIXME: add other output device res */
diff --git a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_bsp_sun8iw7.c b/drivers/video/sunxi/disp2/hdmi/aw/hdmi_bsp_sun8iw7.c
index 230220eb07be..eb6397a5f7f3 100755
--- a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_bsp_sun8iw7.c
+++ b/drivers/video/sunxi/disp2/hdmi/aw/hdmi_bsp_sun8iw7.c
@@ -72,6 +72,7 @@ static struct para_tab ptbl[] =
 	{{39        , 4     , 0,    96,     5,   9,     3,  1,  18, 0,  1,  160,    216,    32,    152,     132,    37, 1,  1	}},
 	{{40        , 2     , 0,    96,     6,   3,     4,  2,   1, 0,  0,  144,     64,   104,    184,      26,    44, 1,  1	}},
 	{{41	    , 1     , 0,    96,     8,   3,     6,  0,   1, 0,  0,  128,    208,   128,    216,       0,    45, 1,  1	}},
+	{{42        , 4     , 0,    0,      6,   3,     3,  1,   3, 0,  0,  64,     96,     24,    168,     132,    37, 1,  1   }},
 };
 
 static unsigned char ca_table[64]=
diff --git a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_core.c b/drivers/video/sunxi/disp2/hdmi/aw/hdmi_core.c
index 306e810413d8..cee223b2431f 100755
--- a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_core.c
+++ b/drivers/video/sunxi/disp2/hdmi/aw/hdmi_core.c
@@ -51,6 +51,7 @@ disp_video_timings video_timing[] =
 	{HDMI1440_900P,      0,108000000, 0,  1440,   900,  1848,  248,   48, 112,   942,  38,  1,  3,  1,   1,   0,    0,  0},
 	{HDMI1680_1050P,     0,147000000, 0,  1680,  1050,  2256,  288,  104, 184,  1087,  33,  1,  3,  1,   1,   0,    0,  0},
 	{HDMI2048_1536P,     0,172040000, 0,  2048,  1536,  2736,  344,  128, 216,  1572,  32,  1,  3,  1,   1,   0,    0  ,0},
+	{HDMI1600_900P,      0,119000000, 0,  1600,  900,   2128,  264,  96,  168,  932,   28,  1,  3,  0,   1,   0,    0  ,0},
 	{ HDMI_EDID, },
 };
 
diff --git a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_edid.c b/drivers/video/sunxi/disp2/hdmi/aw/hdmi_edid.c
index 87e1fe98ede7..fd40988ad41e 100755
--- a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_edid.c
+++ b/drivers/video/sunxi/disp2/hdmi/aw/hdmi_edid.c
@@ -181,6 +181,9 @@ static __s32 Parse_DTD_Block(__u8 *pbuf)
 		if ((sizex== 1680) && (sizey == 1050)) {
 			Device_Support_VIC[HDMI1680_1050P] = 1;
  		}
+		if ((sizex== 1600) && (sizey == 900)) {
+			Device_Support_VIC[HDMI1600_900P] = 1;
+ 		}
 		if ((sizex== 2048) && (sizey == 1536)) {
 			Device_Support_VIC[HDMI2048_1536P] = 1;
 		}
@@ -219,6 +222,9 @@ static __s32 Parse_DTD_Block(__u8 *pbuf)
 		if ((sizex== 1680) && (sizey == 1050)) {
 			Device_Support_VIC[HDMI1680_1050P] = 1;
  		}
+		if ((sizex== 1600) && (sizey == 900)) {
+			Device_Support_VIC[HDMI1600_900P] = 1;
+ 		}
 		if ((sizex== 2048) && (sizey == 1536)) {
 			Device_Support_VIC[HDMI2048_1536P] = 1;
 		}
diff --git a/drivers/video/sunxi/disp2/hdmi/drv_hdmi.c b/drivers/video/sunxi/disp2/hdmi/drv_hdmi.c
index e462c86114a4..75d95554ab86 100755
--- a/drivers/video/sunxi/disp2/hdmi/drv_hdmi.c
+++ b/drivers/video/sunxi/disp2/hdmi/drv_hdmi.c
@@ -291,6 +291,7 @@ static struct disp_hdmi_mode hdmi_mode_tbl[] = {
 	{DISP_TV_MOD_1440_900P,           HDMI1440_900P,     },
 	{DISP_TV_MOD_1680_1050P,          HDMI1680_1050P,    },
 	{DISP_TV_MOD_2048_1536P,          HDMI2048_1536P,    },
+	{DISP_TV_MOD_1600_900P,           HDMI1600_900P,     },
 };
 
 __u32 Hdmi_get_vic(u32 mode)
diff --git a/drivers/video/sunxi/disp2/hdmi/hdmi_hal.h b/drivers/video/sunxi/disp2/hdmi/hdmi_hal.h
index 044bbe8efa89..883fba170d11 100755
--- a/drivers/video/sunxi/disp2/hdmi/hdmi_hal.h
+++ b/drivers/video/sunxi/disp2/hdmi/hdmi_hal.h
@@ -23,6 +23,7 @@
 #define HDMI1440_900P           39
 #define HDMI1680_1050P          40
 #define HDMI2048_1536P          41
+#define HDMI1600_900P           42
 #define HDMI1080P_24_3D_FP  (HDMI1080P_24 +0x80)
 #define HDMI720P_50_3D_FP   (HDMI720P_50  +0x80)
 #define HDMI720P_60_3D_FP   (HDMI720P_60  +0x80)
diff --git a/include/video/sunxi_display2.h b/include/video/sunxi_display2.h
index 6422c76d0b86..809ff887e4a9 100755
--- a/include/video/sunxi_display2.h
+++ b/include/video/sunxi_display2.h
@@ -137,7 +137,8 @@ typedef enum
 	DISP_TV_MOD_1440_900P           = 0x23,
 	DISP_TV_MOD_1680_1050P          = 0x24,
 	DISP_TV_MOD_2048_1536P          = 0x25,
-	DISP_TV_MODE_NUM                = 0x26,
+	DISP_TV_MOD_1600_900P			= 0x26,
+	DISP_TV_MODE_NUM                = 0x27,
 }disp_tv_mode;
 
 
